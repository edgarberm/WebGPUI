<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>WebGPUI v0.4 - Flexible Layout</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      canvas {
        display: block;
        height: 100vh;
        width: 100vw;
      }
    </style>
  </head>
  <body>
    <canvas id="gpuCanvas"></canvas>
    <script type="module">
      const Infinity = Symbol('Infinity')

      class TextRenderer {
        constructor(dpr = 1) {
          this.canvas = document.createElement('canvas')
          this.ctx = this.canvas.getContext('2d', { willReadFrequently: true })
          this.textureCache = new Map()
          this.dpr = dpr
        }

        measureText(text, fontSize, fontFamily, fontWeight) {
          this.ctx.font = `${fontWeight} ${fontSize * this.dpr}px ${fontFamily}`
          const metrics = this.ctx.measureText(text)

          // Use bounding box metrics
          const left = metrics.actualBoundingBoxLeft || 0
          const right = metrics.actualBoundingBoxRight || metrics.width

          const textWidth = right - left

          // Añade un pequeño extra de seguridad (1px a cada lado)
          const safeExtra = 2 / this.dpr

          return {
            width: Math.ceil((textWidth + safeExtra) * this.dpr) / this.dpr,
            height: Math.ceil(fontSize * 1.4 * this.dpr) / this.dpr,
          }
          // const metrics = this.ctx.measureText(text)
          // return {
          //   width: Math.ceil(metrics.width / this.dpr),
          //   height: Math.ceil(fontSize * 1.5),
          // }
        }

        renderToTexture(device, text, fontSize, fontFamily, fontWeight, color) {
          const cacheKey = `${text}-${fontSize}-${fontFamily}-${fontWeight}-${color.join(
            ','
          )}-${this.dpr}`
          if (this.textureCache.has(cacheKey))
            return this.textureCache.get(cacheKey)

          const size = this.measureText(text, fontSize, fontFamily, fontWeight)
          const padding = 4
          const width = size.width + padding * 2
          const height = size.height + padding * 2

          this.canvas.width = width * this.dpr
          this.canvas.height = height * this.dpr
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
          this.ctx.scale(this.dpr, this.dpr)
          this.ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`
          this.ctx.fillStyle = `rgba(${color[0] * 255}, ${color[1] * 255}, ${
            color[2] * 255
          }, ${color[3]})`
          this.ctx.textBaseline = 'top'
          this.ctx.textAlign = 'left'
          this.ctx.fillText(text, padding, padding)
          this.ctx.setTransform(1, 0, 0, 1, 0, 0)

          const imageData = this.ctx.getImageData(
            0,
            0,
            this.canvas.width,
            this.canvas.height
          )
          const texture = device.createTexture({
            size: [this.canvas.width, this.canvas.height, 1],
            format: 'rgba8unorm',
            usage:
              GPUTextureUsage.TEXTURE_BINDING |
              GPUTextureUsage.COPY_DST |
              GPUTextureUsage.RENDER_ATTACHMENT,
          })
          device.queue.writeTexture(
            { texture },
            imageData.data,
            { bytesPerRow: this.canvas.width * 4 },
            [this.canvas.width, this.canvas.height]
          )

          const result = { texture, width, height }
          this.textureCache.set(cacheKey, result)
          return result
        }
      }

      function View() {
        return {
          explicitWidth: null,
          explicitHeight: null,
          minWidth: null,
          maxWidth: null,
          minHeight: null,
          maxHeight: null,
          paddingVal: 0,
          bgColor: [0.5, 0.5, 0.5, 1],
          childrenArray: null,
          x: 0,
          y: 0,
          w: 0,
          h: 0,

          frame(width, height) {
            const v = { ...this }
            if (typeof width === 'object') {
              Object.assign(v, {
                minWidth: width.minWidth,
                maxWidth: width.maxWidth,
                minHeight: width.minHeight,
                maxHeight: width.maxHeight,
                explicitWidth: width.width,
                explicitHeight: width.height,
              })
            } else {
              v.explicitWidth = width
              v.explicitHeight = height
            }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          padding(p) {
            const v = { ...this, paddingVal: p }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          background(color) {
            const v = { ...this, bgColor: color }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          children(...views) {
            const v = { ...this, childrenArray: views }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          sizeThatFits(proposedWidth, proposedHeight) {
            let width = this.explicitWidth ?? 0
            let height = this.explicitHeight ?? 0
            if (this.maxWidth === Infinity) width = proposedWidth
            if (this.maxHeight === Infinity) height = proposedHeight
            return { width, height }
          },

          layout(x = 0, y = 0, proposedWidth = 1000, proposedHeight = 1000) {
            const size = this.sizeThatFits(proposedWidth, proposedHeight)
            this.x = x + this.paddingVal
            this.y = y + this.paddingVal
            this.w = size.width
            this.h = size.height
          },

          getVertices(canvasWidth, canvasHeight) {
            const x0 = (this.x / canvasWidth) * 2 - 1
            const y0 = 1 - (this.y / canvasHeight) * 2
            const x1 = ((this.x + this.w) / canvasWidth) * 2 - 1
            const y1 = 1 - ((this.y + this.h) / canvasHeight) * 2
            const [r, g, b, a] = this.bgColor
            return new Float32Array([
              x0,
              y0,
              r,
              g,
              b,
              a,
              x1,
              y0,
              r,
              g,
              b,
              a,
              x0,
              y1,
              r,
              g,
              b,
              a,
              x0,
              y1,
              r,
              g,
              b,
              a,
              x1,
              y0,
              r,
              g,
              b,
              a,
              x1,
              y1,
              r,
              g,
              b,
              a,
            ])
          },

          // getAllViews() { return [this] }
          getAllViews() {
            if (this.childrenArray && Array.isArray(this.childrenArray)) {
              return [
                this,
                ...this.childrenArray.flatMap((c) => c.getAllViews()),
              ]
            }
            return [this]
          },
        }
      }

      function Text(content) {
        return {
          ...View(),
          textContent: content,
          fontSize: 16,
          fontFamily: 'system-ui, -apple-system, sans-serif',
          fontWeight: 'normal',
          textColor: [0, 0, 0, 1],
          texture: null,
          isText: true,
          intrinsicWidth: 0,
          intrinsicHeight: 0,

          font(size, family = 'system-ui, -apple-system, sans-serif') {
            const v = { ...this, fontSize: size, fontFamily: family }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          fontWeight(weight) {
            const v = { ...this, fontWeight: weight }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          foregroundColor(color) {
            const v = { ...this, textColor: color }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          sizeThatFits(proposedWidth, proposedHeight) {
            let width = this.explicitWidth ?? this.intrinsicWidth
            let height = this.explicitHeight ?? this.intrinsicHeight
            if (this.maxWidth === Infinity) width = proposedWidth
            if (this.maxHeight === Infinity) height = proposedHeight
            return { width, height }
          },

          layout(x = 0, y = 0, proposedWidth = 1000, proposedHeight = 1000) {
            const size = this.sizeThatFits(proposedWidth, proposedHeight)
            this.x = x + this.paddingVal
            this.y = y + this.paddingVal
            this.w = size.width
            this.h = size.height
          },

          prepareTexture(device, textRenderer) {
            if (!this.texture) {
              const result = textRenderer.renderToTexture(
                device,
                this.textContent,
                this.fontSize,
                this.fontFamily,
                this.fontWeight,
                this.textColor
              )
              this.texture = result.texture
              this.intrinsicWidth = result.width
              this.intrinsicHeight = result.height
              this.w = result.width
              this.h = result.height
            }
          },

          getTexturedVertices(canvasWidth, canvasHeight) {
            const x0 = (this.x / canvasWidth) * 2 - 1
            const y0 = 1 - (this.y / canvasHeight) * 2
            const x1 = ((this.x + this.w) / canvasWidth) * 2 - 1
            const y1 = 1 - ((this.y + this.h) / canvasHeight) * 2
            return new Float32Array([
              x0,
              y0,
              0,
              0,
              x1,
              y0,
              1,
              0,
              x0,
              y1,
              0,
              1,
              x0,
              y1,
              0,
              1,
              x1,
              y0,
              1,
              0,
              x1,
              y1,
              1,
              1,
            ])
          },
        }
      }

      function VStack() {
        return {
          ...View(),
          stackSpacing: 0,
          childrenArray: null,

          spacing(value) {
            const v = { ...this, stackSpacing: value }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          children(...views) {
            const v = { ...this, childrenArray: views }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          sizeThatFits(proposedWidth, proposedHeight) {
            if (
              !this.childrenArray ||
              !Array.isArray(this.childrenArray) ||
              this.childrenArray.length === 0
            ) {
              return { width: 0, height: 0 }
            }
            if (this.explicitWidth && this.explicitHeight)
              return { width: this.explicitWidth, height: this.explicitHeight }

            let totalHeight = 0,
              maxWidth = 0

            for (const child of this.childrenArray) {
              const size = child.sizeThatFits(
                proposedWidth - this.paddingVal * 2,
                proposedHeight
              )
              maxWidth = Math.max(maxWidth, size.width)
              totalHeight += size.height
            }
            totalHeight += Math.max(
              0,
              (this.childrenArray.length - 1) * this.stackSpacing
            )

            let width = this.explicitWidth ?? maxWidth + this.paddingVal * 2
            let height =
              this.explicitHeight ?? totalHeight + this.paddingVal * 2
            if (this.maxWidth === Infinity) width = proposedWidth
            if (this.maxHeight === Infinity) height = proposedHeight
            return { width, height }
          },

          layout(x = 0, y = 0, proposedWidth = 1000, proposedHeight = 1000) {
            const mySize = this.sizeThatFits(proposedWidth, proposedHeight)
            this.x = x
            this.y = y
            this.w = mySize.width
            this.h = mySize.height

            if (!this.childrenArray) return

            let cy = y + this.paddingVal
            const innerWidth = this.w - this.paddingVal * 2

            for (const child of this.childrenArray) {
              const childSize = child.sizeThatFits(innerWidth, proposedHeight)
              child.layout(
                x + this.paddingVal,
                cy,
                innerWidth,
                childSize.height
              )
              cy += child.h + this.stackSpacing
            }
          },

          // layout(x = 0, y = 0, proposedWidth = 1000, proposedHeight = 1000) {
          //   if (!this.childrenArray) return
          //   // const resolved = (this.children && Array.isArray(this.children))
          //   //   ? this.children
          //   //   : this.childrenArray.map(c => {
          //   //       const copy = { ...c }
          //   //       Object.setPrototypeOf(copy, Object.getPrototypeOf(c))
          //   //       return copy
          //   //     })
          //   const resolved = this.childrenArray

          //   const mySize = this.sizeThatFits(proposedWidth, proposedHeight)
          //   this.x = x
          //   this.y = y
          //   this.w = mySize.width
          //   this.h = mySize.height

          //   let cy = y + this.paddingVal
          //   for (const child of resolved) {
          //     child.layout(
          //       x + this.paddingVal,
          //       cy,
          //       this.w - this.paddingVal * 2,
          //       this.h - this.paddingVal * 2
          //     )
          //     cy += child.h + this.stackSpacing
          //   }
          //   this.children = resolved
          // },

          // getAllViews() {
          //   if (!this.children || !Array.isArray(this.children)) return []
          //   return this.children.flatMap((c) =>
          //     c.getAllViews ? c.getAllViews() : [c]
          //   )
          // },
        }
      }

      function HStack() {
        return {
          ...View(),
          stackSpacing: 0,
          childrenArray: null,

          spacing(value) {
            const v = { ...this, stackSpacing: value }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          children(...views) {
            const v = { ...this, childrenArray: views }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          sizeThatFits(proposedWidth, proposedHeight) {
            if (
              !this.childrenArray ||
              !Array.isArray(this.childrenArray) ||
              this.childrenArray.length === 0
            ) {
              return { width: 0, height: 0 }
            }
            if (this.explicitWidth && this.explicitHeight)
              return { width: this.explicitWidth, height: this.explicitHeight }

            let totalWidth = 0,
              maxHeight = 0

            for (const child of this.childrenArray) {
              const size = child.sizeThatFits(
                proposedWidth,
                proposedHeight - this.paddingVal * 2
              )
              totalWidth += size.width
              maxHeight = Math.max(maxHeight, size.height)
            }
            totalWidth += Math.max(
              0,
              (this.childrenArray.length - 1) * this.stackSpacing
            )

            let width = this.explicitWidth ?? totalWidth + this.paddingVal * 2
            let height = this.explicitHeight ?? maxHeight + this.paddingVal * 2
            if (this.maxWidth === Infinity) width = proposedWidth
            if (this.maxHeight === Infinity) height = proposedHeight
            return { width, height }
          },

          layout(x = 0, y = 0, proposedWidth = 1000, proposedHeight = 1000) {
            if (!this.childrenArray) return
            const resolved =
              this.children && Array.isArray(this.children)
                ? this.children
                : this.childrenArray.map((c) => {
                    const copy = { ...c }
                    Object.setPrototypeOf(copy, Object.getPrototypeOf(c))
                    return copy
                  })

            const mySize = this.sizeThatFits(proposedWidth, proposedHeight)
            this.x = x
            this.y = y
            this.w = mySize.width
            this.h = mySize.height

            let cx = x + this.paddingVal
            for (const child of resolved) {
              child.layout(
                cx,
                y + this.paddingVal,
                this.w - this.paddingVal * 2,
                this.h - this.paddingVal * 2
              )
              cx += child.w + this.stackSpacing
            }
            this.children = resolved
          },

          getAllViews() {
            if (!this.children || !Array.isArray(this.children)) return []
            return this.children.flatMap((c) =>
              c.getAllViews ? c.getAllViews() : [c]
            )
          },
        }
      }

      function ZStack() {
        return {
          ...View(),
          childrenArray: null,

          children(...views) {
            const v = { ...this, childrenArray: views }
            Object.setPrototypeOf(v, Object.getPrototypeOf(this))
            return v
          },

          sizeThatFits(proposedWidth, proposedHeight) {
            if (
              !this.childrenArray ||
              !Array.isArray(this.childrenArray) ||
              this.childrenArray.length === 0
            ) {
              return { width: 0, height: 0 }
            }
            if (this.explicitWidth && this.explicitHeight)
              return { width: this.explicitWidth, height: this.explicitHeight }

            let maxWidth = 0,
              maxHeight = 0

            for (const child of this.childrenArray) {
              const size = child.sizeThatFits(
                proposedWidth - this.paddingVal * 2,
                proposedHeight - this.paddingVal * 2
              )
              maxWidth = Math.max(maxWidth, size.width)
              maxHeight = Math.max(maxHeight, size.height)
            }

            let width = this.explicitWidth ?? maxWidth + this.paddingVal * 2
            let height = this.explicitHeight ?? maxHeight + this.paddingVal * 2
            if (this.maxWidth === Infinity) width = proposedWidth
            if (this.maxHeight === Infinity) height = proposedHeight
            return { width, height }
          },

          layout(x = 0, y = 0, proposedWidth = 1000, proposedHeight = 1000) {
            if (!this.childrenArray) return
            const resolved =
              this.children && Array.isArray(this.children)
                ? this.children
                : this.childrenArray.map((c) => {
                    const copy = { ...c }
                    Object.setPrototypeOf(copy, Object.getPrototypeOf(c))
                    return copy
                  })

            const mySize = this.sizeThatFits(proposedWidth, proposedHeight)
            this.x = x
            this.y = y
            this.w = mySize.width
            this.h = mySize.height

            for (const child of resolved) {
              child.layout(
                x + this.paddingVal,
                y + this.paddingVal,
                this.w - this.paddingVal * 2,
                this.h - this.paddingVal * 2
              )
            }
            this.children = resolved
          },

          getAllViews() {
            if (!this.children || !Array.isArray(this.children)) return []
            return this.children.flatMap((c) =>
              c.getAllViews ? c.getAllViews() : [c]
            )
          },
        }
      }

      class WebGPURenderer {
        constructor(canvas, rootView) {
          this.canvas = canvas
          this.rootView = rootView
          this.dpr = window.devicePixelRatio || 1
          this.textRenderer = new TextRenderer(this.dpr)
          this.init()
        }

        async init() {
          if (!navigator.gpu) {
            alert('WebGPU no soportado')
            return
          }

          this.adapter = await navigator.gpu.requestAdapter()
          this.device = await this.adapter.requestDevice()
          this.context = this.canvas.getContext('webgpu')

          this.canvas.width = document.documentElement.clientWidth * this.dpr
          this.canvas.height = document.documentElement.clientHeight * this.dpr
          this.canvas.style.width = document.documentElement.clientWidth + 'px'
          this.canvas.style.height =
            document.documentElement.clientHeight + 'px'

          const format = navigator.gpu.getPreferredCanvasFormat()
          this.context.configure({
            device: this.device,
            format,
            alphaMode: 'premultiplied',
          })

          const colorShader = this.device.createShaderModule({
            code: `
            struct VertexOut {
              @builtin(position) pos: vec4<f32>,
              @location(0) color: vec4<f32>
            };
            @vertex fn vs_main(@location(0) pos: vec2<f32>, @location(1) color: vec4<f32>) -> VertexOut {
              var out: VertexOut;
              out.pos = vec4<f32>(pos, 0.0, 1.0);
              out.color = color;
              return out;
            }
            @fragment fn fs_main(in: VertexOut) -> @location(0) vec4<f32> {
              return in.color;
            }
          `,
          })

          const textureShader = this.device.createShaderModule({
            code: `
            struct VertexOut {
              @builtin(position) pos: vec4<f32>,
              @location(0) uv: vec2<f32>
            };
            @group(0) @binding(0) var texSampler: sampler;
            @group(0) @binding(1) var tex: texture_2d<f32>;
            @vertex fn vs_main(@location(0) pos: vec2<f32>, @location(1) uv: vec2<f32>) -> VertexOut {
              var out: VertexOut;
              out.pos = vec4<f32>(pos, 0.0, 1.0);
              out.uv = uv;
              return out;
            }
            @fragment fn fs_main(in: VertexOut) -> @location(0) vec4<f32> {
              return textureSample(tex, texSampler, in.uv);
            }
          `,
          })

          this.colorPipeline = this.device.createRenderPipeline({
            layout: 'auto',
            vertex: {
              module: colorShader,
              entryPoint: 'vs_main',
              buffers: [
                {
                  arrayStride: 24,
                  attributes: [
                    { shaderLocation: 0, offset: 0, format: 'float32x2' },
                    { shaderLocation: 1, offset: 8, format: 'float32x4' },
                  ],
                },
              ],
            },
            fragment: {
              module: colorShader,
              entryPoint: 'fs_main',
              targets: [
                {
                  format,
                  blend: {
                    color: {
                      srcFactor: 'src-alpha',
                      dstFactor: 'one-minus-src-alpha',
                      operation: 'add',
                    },
                    alpha: {
                      srcFactor: 'one',
                      dstFactor: 'one-minus-src-alpha',
                      operation: 'add',
                    },
                  },
                },
              ],
            },
            primitive: { topology: 'triangle-list' },
          })

          this.texturePipeline = this.device.createRenderPipeline({
            layout: 'auto',
            vertex: {
              module: textureShader,
              entryPoint: 'vs_main',
              buffers: [
                {
                  arrayStride: 16,
                  attributes: [
                    { shaderLocation: 0, offset: 0, format: 'float32x2' },
                    { shaderLocation: 1, offset: 8, format: 'float32x2' },
                  ],
                },
              ],
            },
            fragment: {
              module: textureShader,
              entryPoint: 'fs_main',
              targets: [
                {
                  format,
                  blend: {
                    color: {
                      srcFactor: 'src-alpha',
                      dstFactor: 'one-minus-src-alpha',
                      operation: 'add',
                    },
                    alpha: {
                      srcFactor: 'one',
                      dstFactor: 'one-minus-src-alpha',
                      operation: 'add',
                    },
                  },
                },
              ],
            },
            primitive: { topology: 'triangle-list' },
          })

          this.sampler = this.device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear',
          })
          this.render()
        }

        render() {
          if (!this.device) return

          const logicalWidth = this.canvas.width / this.dpr
          const logicalHeight = this.canvas.height / this.dpr

          const preProcess = (view) => {
            if (view.isText) view.prepareTexture(this.device, this.textRenderer)
            if (view.childrenArray) view.childrenArray.forEach(preProcess)
          }
          preProcess(this.rootView)

          this.rootView.layout(0, 0, logicalWidth - 40, logicalHeight - 40)

          const allViews = this.rootView.getAllViews()
          const colorViews = allViews.filter((v) => !v.isText)
          const textViews = allViews.filter((v) => v.isText)

          const encoder = this.device.createCommandEncoder()
          const renderPass = encoder.beginRenderPass({
            colorAttachments: [
              {
                view: this.context.getCurrentTexture().createView(),
                loadOp: 'clear',
                storeOp: 'store',
                clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1.0 },
              },
            ],
          })

          if (colorViews.length > 0) {
            const verts = new Float32Array(
              colorViews.reduce((sum, v) => sum + 36, 0)
            )
            let offset = 0
            for (const v of colorViews) {
              verts.set(v.getVertices(logicalWidth, logicalHeight), offset)
              offset += 36
            }
            const buf = this.device.createBuffer({
              size: verts.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
              mappedAtCreation: true,
            })
            new Float32Array(buf.getMappedRange()).set(verts)
            buf.unmap()
            renderPass.setPipeline(this.colorPipeline)
            renderPass.setVertexBuffer(0, buf)
            renderPass.draw(verts.length / 6, 1, 0, 0)
          }

          for (const tv of textViews) {
            const verts = tv.getTexturedVertices(logicalWidth, logicalHeight)
            const buf = this.device.createBuffer({
              size: verts.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
              mappedAtCreation: true,
            })
            new Float32Array(buf.getMappedRange()).set(verts)
            buf.unmap()

            const bindGroup = this.device.createBindGroup({
              layout: this.texturePipeline.getBindGroupLayout(0),
              entries: [
                { binding: 0, resource: this.sampler },
                { binding: 1, resource: tv.texture.createView() },
              ],
            })

            renderPass.setPipeline(this.texturePipeline)
            renderPass.setVertexBuffer(0, buf)
            renderPass.setBindGroup(0, bindGroup)
            renderPass.draw(6, 1, 0, 0)
          }

          renderPass.end()
          this.device.queue.submit([encoder.finish()])
          requestAnimationFrame(() => this.render())
        }
      }

      // DEMO con tamaños flexibles
      const root = VStack()
        // .spacing(16)
        .padding(20)
        .children(
          Text('WebGPUI v0.4 - Flexible Layout').font(28).fontWeight('bold'),

          Text('Views adapt to their content size automatically!')
            .font(20)
            .foregroundColor([0.4, 0.4, 0.4, 1]),

          View()
            .frame({ maxWidth: Infinity, height: 2 })
            .background([0.8, 0.8, 0.8, 1]),

          VStack()
            // .spacing(8)
            // .padding(16)
            .background([1, 0.95, 0.9, 0.1])
            .children(
              Text('This VStack adapts to its children')
                .font(14)
                .fontWeight('600'),
              Text('No explicit frame needed!')
                .font(20)
                .foregroundColor([0.5, 0.5, 0.5, 1])
            ),

          HStack()
            .spacing(12)
            .children(
              VStack()
                .padding(12)
                .background([1, 0.3, 0.3, 1])
                .children(
                  Text('Auto').foregroundColor([1, 1, 1, 1]).fontWeight('bold'),
                  Text('Size').font(12).foregroundColor([1, 1, 1, 0.8])
                ),

              VStack()
                .padding(12)
                .background([0.3, 0.6, 1, 1])
                .children(
                  Text('Flexible')
                    .foregroundColor([1, 1, 1, 1])
                    .fontWeight('bold'),
                  Text('Layout').font(12).foregroundColor([1, 1, 1, 0.8])
                ),

              View()
                .frame({ maxWidth: Infinity, height: 60 })
                .background([0, 0.7, 0, 1])
            ),

          Text('↑ The green box uses maxWidth: Infinity')
            .font(11)
            .foregroundColor([0.5, 0.5, 0.5, 1]),

          VStack()
            .frame({ maxWidth: Infinity })
            .padding(16)
            .background([0.2, 0.2, 0.8, 1])
            .children(
              Text('Full width VStack')
                .foregroundColor([1, 1, 1, 1])
                .font(16)
                .fontWeight('bold')
            )
        )

      new WebGPURenderer(document.getElementById('gpuCanvas'), root)
    </script>
  </body>
</html>
