<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>WebGPUI v0.6 - Text & Layout Fix</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="gpuCanvas"></canvas>
    <script type="module">
      const Infinity = Symbol('Infinity')

      // ================= TEXT RENDERER =================
      class TextRenderer {
        constructor(dpr = 1) {
          this.canvas = document.createElement('canvas')
          this.ctx = this.canvas.getContext('2d')
          this.textureCache = new Map()
          this.dpr = dpr
        }

        measureText(text, fontSize, fontFamily, fontWeight) {
          this.ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`
          const m = this.ctx.measureText(text)
          return {
            width: Math.ceil(m.width),
            height: Math.ceil(fontSize * 1.0),
          }
        }

        renderToTexture(device, text, fontSize, fontFamily, fontWeight, color) {
          const key = `${text}-${fontSize}-${fontWeight}-${color.join()}`
          if (this.textureCache.has(key)) return this.textureCache.get(key)

          const padding = 4
          const size = this.measureText(text, fontSize, fontFamily, fontWeight)
          const w = size.width + padding * 2
          const h = size.height + padding * 2

          this.canvas.width = w * this.dpr
          this.canvas.height = h * this.dpr
          this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0)

          // IMPORTANTE: Limpiar con transparencia
          this.ctx.clearRect(0, 0, w, h)

          this.ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`
          this.ctx.fillStyle = `rgba(${color.map((c) => c * 255).join(',')})`
          this.ctx.textBaseline = 'top'
          this.ctx.fillText(text, padding, padding)

          const img = this.ctx.getImageData(
            0,
            0,
            this.canvas.width,
            this.canvas.height
          )
          const tex = device.createTexture({
            size: [this.canvas.width, this.canvas.height],
            format: 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
          })
          device.queue.writeTexture(
            { texture: tex },
            img.data,
            { bytesPerRow: this.canvas.width * 4 },
            [this.canvas.width, this.canvas.height]
          )

          const res = { texture: tex, width: w, height: h }
          this.textureCache.set(key, res)
          return res
        }
      }

      // ================= BASE VIEW =================
      class View {
        constructor() {
          this.explicitWidth = null
          this.explicitHeight = null
          this.maxWidth = null
          this.maxHeight = null
          this.paddingVal = 0
          this.bgColor = [0.5, 0.5, 0.5, 1]
          this.childrenArray = []
          this.measuredWidth = 0
          this.measuredHeight = 0
          this.x = this.y = this.w = this.h = 0
        }

        frame(v, h) {
          if (typeof v === 'object') {
            this.explicitWidth = v.width ?? null
            this.explicitHeight = v.height ?? null
            this.maxWidth = v.maxWidth ?? null
            this.maxHeight = v.maxHeight ?? null
          } else {
            this.explicitWidth = v
            this.explicitHeight = h
          }
          return this
        }

        padding(p) {
          this.paddingVal = p
          return this
        }
        background(c) {
          this.bgColor = c
          return this
        }
        children(...c) {
          this.childrenArray = c
          return this
        }

        measure() {
          this.measuredWidth = this.explicitWidth ?? this.paddingVal * 2
          this.measuredHeight = this.explicitHeight ?? this.paddingVal * 2
        }

        layout(x, y, aw, ah) {
          this.x = x
          this.y = y
          this.w =
            this.maxWidth === Infinity ? aw : Math.min(this.measuredWidth, aw)
          this.h =
            this.maxHeight === Infinity ? ah : Math.min(this.measuredHeight, ah)
        }

        getVertices(cw, ch) {
          const x0 = (this.x / cw) * 2 - 1
          const y0 = 1 - (this.y / ch) * 2
          const x1 = ((this.x + this.w) / cw) * 2 - 1
          const y1 = 1 - ((this.y + this.h) / ch) * 2
          const [r, g, b, a] = this.bgColor
          return new Float32Array([
            x0,
            y0,
            r,
            g,
            b,
            a,
            x1,
            y0,
            r,
            g,
            b,
            a,
            x0,
            y1,
            r,
            g,
            b,
            a,
            x0,
            y1,
            r,
            g,
            b,
            a,
            x1,
            y0,
            r,
            g,
            b,
            a,
            x1,
            y1,
            r,
            g,
            b,
            a,
          ])
        }

        getAllViews() {
          return [this, ...this.childrenArray.flatMap((c) => c.getAllViews())]
        }
      }

      // ================= TEXT =================
      class Text extends View {
        constructor(content) {
          super()
          this.textContent = content
          this.fontSize = 16
          this.fontFamily = 'system-ui,-apple-system,sans-serif'
          this._fontWeight = 'normal'
          this.textColor = [0, 0, 0, 1]
          this.texture = null
          this.isText = true
        }

        font(size, family = 'system-ui,-apple-system,sans-serif') {
          this.fontSize = size
          this.fontFamily = family
          this.texture = null
          return this
        }

        fontWeight(weight) {
          this._fontWeight = weight
          this.texture = null
          return this
        }
        foregroundColor(color) {
          this.textColor = color
          this.texture = null
          return this
        }

        measure(textRenderer) {
          const ts = textRenderer.measureText(
            this.textContent,
            this.fontSize,
            this.fontFamily,
            this._fontWeight
          )
          const padding = 4
          this.measuredWidth = ts.width + padding * 2
          this.measuredHeight = ts.height + padding * 2
        }

        layout(x, y, availableWidth, availableHeight) {
          this.x = x
          this.y = y
          this.w =
            this.maxWidth === Infinity
              ? availableWidth
              : Math.min(this.measuredWidth, availableWidth)
          this.h =
            this.maxHeight === Infinity
              ? availableHeight
              : Math.min(this.measuredHeight, availableHeight)
        }

        prepareTexture(device, textRenderer) {
          if (!this.texture) {
            const res = textRenderer.renderToTexture(
              device,
              this.textContent,
              this.fontSize,
              this.fontFamily,
              this._fontWeight,
              this.textColor
            )
            this.texture = res.texture
            this.texWidth = res.width
            this.texHeight = res.height
          }
        }

        getTexturedVertices(canvasWidth, canvasHeight) {
          const x0 = (this.x / canvasWidth) * 2 - 1
          const y0 = 1 - (this.y / canvasHeight) * 2
          const x1 = ((this.x + this.w) / canvasWidth) * 2 - 1
          const y1 = 1 - ((this.y + this.h) / canvasHeight) * 2
          return new Float32Array([
            x0,
            y0,
            0,
            0,
            x1,
            y0,
            1,
            0,
            x0,
            y1,
            0,
            1,
            x0,
            y1,
            0,
            1,
            x1,
            y0,
            1,
            0,
            x1,
            y1,
            1,
            1,
          ])
        }
      }

      // ================= STACKS =================
      class VStack extends View {
        spacing(v) {
          this.stackSpacing = v
          return this
        }
        measure(tr) {
          let w = 0,
            h = this.paddingVal * 2
          this.childrenArray.forEach((c) => {
            c.measure(tr)
            w = Math.max(w, c.measuredWidth)
            h += c.measuredHeight
          })
          h += (this.childrenArray.length - 1) * (this.stackSpacing || 0)
          this.measuredWidth = this.explicitWidth ?? w + this.paddingVal * 2
          this.measuredHeight = this.explicitHeight ?? h
        }
        layout(x, y, aw, ah) {
          super.layout(x, y, aw, ah)
          let cy = y + this.paddingVal
          const iw = this.w - this.paddingVal * 2
          this.childrenArray.forEach((c) => {
            c.layout(x + this.paddingVal, cy, iw, c.measuredHeight)
            cy += c.h + (this.stackSpacing || 0)
          })
        }
      }

      class HStack extends View {
        spacing(v) {
          this.stackSpacing = v
          return this
        }
        measure(tr) {
          let w = this.paddingVal * 2,
            h = 0
          this.childrenArray.forEach((c) => {
            c.measure(tr)
            w += c.measuredWidth
            h = Math.max(h, c.measuredHeight)
          })
          w += (this.childrenArray.length - 1) * (this.stackSpacing || 0)
          this.measuredWidth = this.explicitWidth ?? w
          this.measuredHeight = this.explicitHeight ?? h + this.paddingVal * 2
        }
        layout(x, y, aw, ah) {
          super.layout(x, y, aw, ah)
          let cx = x + this.paddingVal
          this.childrenArray.forEach((c) => {
            c.layout(cx, y + this.paddingVal, c.measuredWidth, this.h)
            cx += c.w + (this.stackSpacing || 0)
          })
        }
      }

      // ================= RENDERER =================
      class WebGPURenderer {
        constructor(canvas, root) {
          this.canvas = canvas
          this.root = root
          this.dpr = window.devicePixelRatio || 1
          this.textRenderer = new TextRenderer(this.dpr)
          this.init()
        }

        async init() {
          const adapter = await navigator.gpu.requestAdapter()
          this.device = await adapter.requestDevice()
          this.ctx = this.canvas.getContext('webgpu')
          const format = navigator.gpu.getPreferredCanvasFormat()
          this.ctx.configure({ device: this.device, format })

          // pipeline para rects
          const colorShader = this.device.createShaderModule({
            code: `
          struct VSOut{
            @builtin(position) pos:vec4<f32>,
            @location(0) color:vec4<f32>,
          };
          @vertex fn vs(@location(0) pos:vec2<f32>,@location(1) color:vec4<f32>)->VSOut{
            var out:VSOut;
            out.pos=vec4<f32>(pos,0.0,1.0);
            out.color=color;
            return out;
          }
          @fragment fn fs(@location(0) color:vec4<f32>)->@location(0) vec4<f32>{ return color; }
        `,
          })
          this.rectPipeline = this.device.createRenderPipeline({
            layout: 'auto',
            vertex: {
              module: colorShader,
              entryPoint: 'vs',
              buffers: [
                {
                  arrayStride: 24,
                  attributes: [
                    { shaderLocation: 0, offset: 0, format: 'float32x2' },
                    { shaderLocation: 1, offset: 8, format: 'float32x4' },
                  ],
                },
              ],
            },
            fragment: {
              module: colorShader,
              entryPoint: 'fs',
              targets: [{ format }],
            },
            primitive: { topology: 'triangle-list' },
          })

          // pipeline para texto CON BLENDING
          const textShader = this.device.createShaderModule({
            code: `
          @group(0) @binding(0) var myTex: texture_2d<f32>;
          @group(0) @binding(1) var mySampler: sampler;
          struct VSOut{
            @builtin(position) pos: vec4<f32>,
            @location(0) uv: vec2<f32>
          };
          @vertex fn vs(@location(0) pos:vec2<f32>,@location(1) uv:vec2<f32>)->VSOut{
            var out:VSOut;
            out.pos=vec4<f32>(pos,0.0,1.0);
            out.uv=uv;
            return out;
          }
          @fragment fn fs(@location(0) uv:vec2<f32>)->@location(0) vec4<f32>{
            return textureSample(myTex,mySampler,uv);
          }
        `,
          })

          this.textPipeline = this.device.createRenderPipeline({
            layout: 'auto',
            vertex: {
              module: textShader,
              entryPoint: 'vs',
              buffers: [
                {
                  arrayStride: 16,
                  attributes: [
                    { shaderLocation: 0, offset: 0, format: 'float32x2' },
                    { shaderLocation: 1, offset: 8, format: 'float32x2' },
                  ],
                },
              ],
            },
            fragment: {
              module: textShader,
              entryPoint: 'fs',
              targets: [
                {
                  format,
                  blend: {
                    color: {
                      srcFactor: 'src-alpha',
                      dstFactor: 'one-minus-src-alpha',
                      operation: 'add',
                    },
                    alpha: {
                      srcFactor: 'one',
                      dstFactor: 'one-minus-src-alpha',
                      operation: 'add',
                    },
                  },
                },
              ],
            },
            primitive: { topology: 'triangle-list' },
          })

          this.sampler = this.device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear',
          })

          this.render()
        }

        render() {
          const w = (this.canvas.width = innerWidth * this.dpr)
          const h = (this.canvas.height = innerHeight * this.dpr)

          this.root.measure(this.textRenderer)
          this.root.layout(0, 0, w / this.dpr, h / this.dpr)

          const encoder = this.device.createCommandEncoder()
          const pass = encoder.beginRenderPass({
            colorAttachments: [
              {
                view: this.ctx.getCurrentTexture().createView(),
                loadOp: 'clear',
                storeOp: 'store',
                clearValue: { r: 0.95, g: 0.95, b: 0.95, a: 1 },
              },
            ],
          })

          // dibujar rects
          const views = this.root.getAllViews().filter((v) => !v.isText)
          if (views.length) {
            const verts = new Float32Array(
              views.flatMap((v) => [
                ...v.getVertices(w / this.dpr, h / this.dpr),
              ])
            )
            const buf = this.device.createBuffer({
              size: verts.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
              mappedAtCreation: true,
            })
            new Float32Array(buf.getMappedRange()).set(verts)
            buf.unmap()
            pass.setPipeline(this.rectPipeline)
            pass.setVertexBuffer(0, buf)
            pass.draw(verts.length / 6)
          }

          // dibujar textos
          const texts = this.root.getAllViews().filter((v) => v.isText)
          texts.forEach((t) => {
            t.prepareTexture(this.device, this.textRenderer)
            const verts = new Float32Array(
              t.getTexturedVertices(w / this.dpr, h / this.dpr)
            )
            const buf = this.device.createBuffer({
              size: verts.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
              mappedAtCreation: true,
            })
            new Float32Array(buf.getMappedRange()).set(verts)
            buf.unmap()

            const bindGroup = this.device.createBindGroup({
              layout: this.textPipeline.getBindGroupLayout(0),
              entries: [
                { binding: 0, resource: t.texture.createView() },
                { binding: 1, resource: this.sampler },
              ],
            })

            pass.setPipeline(this.textPipeline)
            pass.setBindGroup(0, bindGroup)
            pass.setVertexBuffer(0, buf)
            pass.draw(verts.length / 4)
          })

          pass.end()
          this.device.queue.submit([encoder.finish()])
          requestAnimationFrame(() => this.render())
        }
      }

      // ================= DEMO =================
      const root = new VStack()
        .spacing(10)
        .padding(20)
        // .frame({ maxWidth: Infinity })
        .children(
          new Text('WebGPUI v0.6')
            .font(28)
            .fontWeight('bold')
            .foregroundColor([0.2, 0.2, 0.8, 1]),

          new View()
            .frame({ width: 300, height: 2 })
            .background([0.3, 0.6, 0.9, 1]),

          new Text('Layout now flows correctly!')
            .font(16)
            .foregroundColor([0, 0, 0, 1]),

          new HStack()
            // .spacing(12)
            .padding(16)
            .background([1, 1, 1, 0.8])
            .frame({ maxWidth: Infinity })
            .children(
              new Text('Â¡Funciona!')
                .font(14)
                .fontWeight('600')
                .foregroundColor([0.2, 0.7, 0.3, 1]),
              new Text('WebGPU mola')
                .font(14)
                .foregroundColor([0.5, 0.5, 0.5, 1])
            )
        )

      new WebGPURenderer(document.getElementById('gpuCanvas'), root)
    </script>
  </body>
</html>
